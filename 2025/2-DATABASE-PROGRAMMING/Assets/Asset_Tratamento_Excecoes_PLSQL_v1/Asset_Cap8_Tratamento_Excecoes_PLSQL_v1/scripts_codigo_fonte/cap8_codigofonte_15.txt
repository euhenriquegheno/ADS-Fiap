-- Script que aplica o conceito das funções
-- SQLCODE e SQLERRM 
SET SERVEROUTPUT ON;
DECLARE
	-- Variável que irá controlar quantas linhas foram manipuladas.
	V_CONTADOR_CURSOR NUMBER := 00;
	V_SQL_CODIGO_ERRO   NUMBER;
	V_SQL_MENSAGEM_ERRO VARCHAR2(4000);
BEGIN
	-- Perceba que estamos usando o FOR LOOP diretamente
	-- com um subconsulta, eliminando assim a necessidade 
	-- de escrita comando CURSOR.
	FOR i IN (
				SELECT 	NR_CLIENTE, 
						ROUND(AVG(VL_TOT_PEDIDO),2) VL_MEDIO_VENDAS
				FROM  	DB_PEDIDO
				WHERE 	EXTRACT(YEAR FROM DT_PEDIDO) = EXTRACT(YEAR FROM SYSDATE)
				GROUP 	BY NR_CLIENTE
				)
	LOOP
	 	-- Para cada cliente selecionado, atualizamos o seu respectivo
		-- valor médio de vendas, utilizando como chave o número do cliente.
		UPDATE DB_CLIENTE SET VL_MEDIO_COMPRA = i.VL_MEDIO_VENDAS
		WHERE NR_CLIENTE = i.NR_CLIENTE;
	
		-- A cada linha processada, acumulamos o valor na variavel v_contador_cursor.
		V_CONTADOR_CURSOR := V_CONTADOR_CURSOR + SQL%ROWCOUNT;

		BEGIN

            i.VL_MEDIO_VENDAS := i.VL_MEDIO_VENDAS ** 999999999999999999999999999999999999999999999999999;
            DBMS_OUTPUT.PUT_LINE ( I.VL_MEDIO_VENDAS);
            
		EXCEPTION
			-- Veja q exceção pré-definida ZERO_DIVIDE que trata da divisão por zero
            WHEN ZERO_DIVIDE THEN
                 DBMS_OUTPUT.PUT_LINE('Perceba que a exceção foi acionada para o cliente (' || i.NR_CLIENTE || ') e podemos tratar da maneira que quisermos, sem parar o processmaento!');
			-- Veja a exceção OTHERS que trata de qualquer outra exceção que ainda não foi definida
			WHEN OTHERS THEN
				V_SQL_CODIGO_ERRO := SQLCODE;
				V_SQL_MENSAGEM_ERRO := SQLERRM;
		         DBMS_OUTPUT.PUT_LINE(	'Exceção crítica para o cliente (' || i.NR_CLIENTE || ') ' || 
										V_SQL_CODIGO_ERRO || ' * ' || V_SQL_MENSAGEM_ERRO);
		END;
	END LOOP;

END;